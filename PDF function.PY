# -*- coding: utf-8 -*-
"""OFFICE_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1i24fgpezBh6VsCyXOv1DKE5-P1I_v9gc

### Mounting the google drive

Using Google drive as the directory to handle files
"""

from google.colab import drive
drive.mount('/content/drive')

"""location of the dataset

click the folder icon on the left side of the colab notebook. Go to drive to locate your file and get the path of the national grid data locaated in the drive and paste it hear upto the folder which contains the file. the link given here is f'/content/drive/MyDrive/OFFICE/fNew {YEAR} {MONTH}.csv'. copy the link and paste it till the OFFICE/
"""

YEAR = int(input('Enter the year for finding the Dataset ---> '))
MONTH = int(input('Enter the month for finding the Dataset---> '))

"""**Input the year and the month to select the dataset**"""

dataset = f'/content/drive/MyDrive/OFFICE/fnew-2022-2/fNew {YEAR} {MONTH}.csv'

import pandas as pd
import numpy as np
from scipy.stats import norm
import matplotlib.pyplot as plt
import statistics
import numpy

"""**Printing the variables**"""

df = pd.read_csv(dataset)
for i in (df[:0]):
  print(i)

df['f']
data_to_list = []
for entities in df['f']:
  data_to_list.append(entities)

M = df['f'].mean()
print(f'the mean of the frequencies is {M}')
STD = df['f'].std()
print(f'the std of the frequencies is {STD}')

def pdf(x):
    mean = np.mean(x)
    std = np.std(x)
    y_out = 1/(std * np.sqrt(2 * np.pi)) * np.exp( - (x - mean)**2 / (2 * std**2))
    return y_out

"""### Normal distribtion function (PDF curve)

"""

plt.style.use('seaborn')
plt.figure(figsize = (6, 6))
# plt.plot(data_to_list, y, color = 'black',
#          linestyle = 'dashed')
  
plt.scatter( data_to_list, pdf(data_to_list), marker = 'o', s = 5, color = 'red')
# plt.fill_between(data_to_list, 
#                  pdf(data_to_list) ,
#                  facecolor='blue',
#                  alpha=0.35)
plt.show()

from scipy.integrate import quad

"""**Enter the x and y value to get the percentage of values that lies in the bell curve **

```
result, _ = quad(gaus_dist_func, x, y)
result_1, _1 = quad(gaus_dist_func, x, y)
```


"""

def gaus_dist_func(x):
  return(1/(0.06750069609422339 * np.sqrt(2 * np.pi)) * np.exp( - (x - 49.99878943617802)**2 / (2 * 0.06750069609422339**2)))

result, _ = quad(gaus_dist_func, 49.9, 50.1)
result_1, _1 = quad(gaus_dist_func, 49.8, 50.2)
print(f'{result*100} percentage of the values lies in 1 STD')
print(f'{result_1*100} percentage of the values lies in 2 STD')

df['f'].describe().transpose()

def pdf_2(x):
  constant = 1.0 / np.sqrt(2*np.pi)
  pdf_normal_distribution = constant * np.exp(-(np.power(x,2)) / 2.0)
  return pdf_normal_distribution

"""### Normal distribution function"""

df[['Date','time']] = df.dtm.str.split(" ",expand=True,)

list_of_vals = []

list_of_vals.clear()
for num in range (len(df)):
  num_1 = df['f'][num]
  try:
    num_2 = df['f'][num+1]
  except:
    KeyError
  value = np.subtract(num_1, num_2)
  list_of_vals.append(value)

len(list_of_vals)
df[['deadband']] = pd.DataFrame(list_of_vals)

df['f'][1]-df['f'][2]

df

df['failure'] = df['deadband'].apply(lambda x: 1 if (abs(x)>0.015) else 0)

df

plt.scatter([x for x in range (len(df))], df['failure'] )

plt.plot([x for x in range (len(df))],df['deadband'])
plt.xlabel('Seconds')
plt.ylabel('Deadband frequency in HZ')
print(df['deadband'].describe())

from sklearn.linear_model import LogisticRegression, LinearRegression
from sklearn.datasets import make_classification
from sklearn.model_selection import train_test_split

for num in range (len(df)):
  pass

format = '%Y-%m-%d'

x = 0
for i in df['Date']:

  if i == '2022-02-04':
    x+=1
print(f'Number of datas in one day is:- {x}')

val = len(df['dtm'])

sec = []
for num in range (len(df['dtm'])):
  sec.append(num)

len(sec)

plt.scatter(sec, data_to_list, marker = 'o', s = 5, color = 'red')
plt.show()

increment = 0
date_1 = []
while df['Date'][increment] == '2022-02-01':
  date_1.append(df['f'][increment])
  increment+=1
print(date_1)
plt.scatter([x for x in np.linspace(0, 24.0, num=len(date_1))], date_1, marker = 'o', s = 5, color = 'red')

"""### Bell curve generation for different days

Get the mean, max and std of each month
"""

no_of_dates = ['01','02','03','04','05','06','07','08','09','10','11','12','13','14','15','16','17','18','19','20','21','22','23','24','25','26','27','28','29','30','31']
for i in no_of_dates:
  try:
    dataset_sorted = df.groupby(['Date']).get_group((f"2022-02-{i}"))
    plt.scatter(dataset_sorted['f'], pdf(dataset_sorted['f']), marker = 'o', s = 5, color = 'red')
    plt.legend([f'PDF of frequencies noted on 2022-02-{i}'])
    plt.xlabel('Frequency')
    plt.ylabel('PDF of Frequency')
    plt.show()
    print(df['f'].describe().transpose())
  except:
    KeyError

"""# Frequency noted on different days in a month"""

for i in no_of_dates:
  try:
    dataset_sorted = df.groupby(['Date']).
    



    
    plt.scatter([x for x in np.linspace(0, 24.0, num=len(dataset_sorted['f']))], dataset_sorted['f'], marker = 'o', s = 5, color = 'red')
    plt.legend([f'frequencies noted on 2022-02-{i}'])
    plt.xlabel('Dates')
    plt.ylabel('Frequency')
    plt.show()
    # print(df['f'].describe().transpose())
  except:
    KeyError

